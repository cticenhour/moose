# * This file is part of the MOOSE framework
# * https://mooseframework.inl.gov
# *
# * All rights reserved, see COPYRIGHT for full restrictions
# * https://github.com/idaholab/moose/blob/master/COPYRIGHT
# *
# * Licensed under LGPL 2.1, please see LICENSE for details
# * https://www.gnu.org/licenses/lgpl-2.1.html

from dataclasses import dataclass, field
import enum
import os
import numpy as np
from collections import OrderedDict
from typing import Optional, Callable, Iterable

import pyhit
from MooseControl import MooseControl
from MooseControl.MooseControl import logger


@dataclass
class StochasticRunOptions:
    """Options for running with the Stochastic Tools Module

    Parameters:
        num_procs (int): The number of processors to run with (default=1).
        mpi_command (str): Command for MPI execution (default='mpiexec').
        input_name (str): Name of the input file which will be generated by
                          StochasticControl (default='stochastic_run.i')
        cli_args (list[str]): List of additional command-line arguments to
                              provide at execution.
        min_procs_per_sample (int): See documentation for
                                    MultiApps/SamplerFullSolveMultiApp/min_procs_per_app.
        multiapp_mode (MultiAppMode): See documentation for
                                      StochasticRunOptions.MultiAppMode
                                      (default=BATCH_RESET).
        ignore_solve_not_converge (bool): Whether or not to continue sampling
                                          if a solve fails (default=False).
    """

    class MultiAppMode(enum.IntEnum):
        """Enumeration of mode of stochastic execution.
        See "Execution Mode" section of ParameterStudy syntax documentation for
        equivalent details.
        """

        NORMAL = 0
        BATCH_RESET = 1
        BATCH_RESTORE = 2
        BATCH_KEEP_SOLUTION = 3
        BATCH_NO_RESTORE = 4

        @property
        def mode(self) -> str:
            """Mode string to send to multi-app parameter."""
            if self.value == 0:
                return "normal"
            elif self.value == 1:
                return "batch-reset"
            else:
                return "batch-restore"

        @property
        def is_restore(self) -> bool:
            """Whether or not this is in 'restore' mode.
            Facilitates how parameters are transferred to sub-application.
            """
            return self.value > 1

    num_procs: int = 1
    mpi_command: str = "mpiexec"
    input_name: str = "stochastic_run.i"
    cli_args: list[str] = field(default_factory=list)
    min_procs_per_sample: int = None
    multiapp_mode: MultiAppMode = MultiAppMode.BATCH_RESET
    ignore_solve_not_converge: bool = False


DEFAULT_OPTIONS = StochasticRunOptions()


class StochasticControl(MooseControl):
    """
    A MOOSE control interface for executing stochastic sampling runs
    using the StochasticTools module.

    This class automates the setup of input files, execution, and retrieval
    of results (quantities of interest, QoIs) based on sampled parameters.

    Example Usage::

        from moose_stochastic_tools import StochasticControl, StochasticRunOptions

        executable = '...' # Path to MOOSE executable with STM enabled
        input_file = 'physics.i'
        params = [...] # Parameters in physics input to modify
        qois = [...] # Reporter value names to retrieve after running the physics input
        opts = StochasticRunOptions(num_procs=<n>)
        with StochasticControl(executable, input_file, params, qois, opts) as runner:
            while sampling:
                x = ... # Produce sampling matrix
                y = runner(x) # Retrieve results

    Attributes:
        sampler_name: The name of the sampler block.
        web_server_control_name: Name used for web server-based control.
        multiapp_name: Name for the multiapp runner.
        sample_receiver_name: Control block name for parameter receivers.
        parameter_transfer_name: Name for parameter transfer/control block.
        qoi_storage_name: Name of the reporter storing QoIs.
        qoi_transfer_name: Name of the transfer block for QoIs.
        controllable_matrix: The path to the sampler matrix block.
    """

    # Object names for the input
    sampler_name = "sample"
    web_server_control_name = "matrix_control"
    multiapp_name = "runner"
    sample_receiver_name = "parameter_receiver"
    parameter_transfer_name = "param"
    qoi_storage_name = "storage"
    qoi_transfer_name = "data"
    controllable_matrix = f"Samplers/{sampler_name}/matrix"

    def __init__(
        self,
        executable: str,
        physics_input: str,
        parameters: list[str],
        quantities_of_interest: list[str],
        options: StochasticRunOptions = DEFAULT_OPTIONS,
        physics_cli_args: list[str] = [],
        moose_port: int = None,
        inherit_environment: bool = True,
        poll_time: float = 0.1,
    ):
        """
        Initialize the StochasticControl object with executable, input and control options.

        1. Builds a pyhit.Node ready to be written to a file once sampling starts
        2. Constructs MOOSE command to be sent to base class so server will start.

        Parameters:
            executable (str): Path to the MOOSE executable.
            physics_input (str): Filename of the physics simulation input.
            parameters (list[str]): List of parameter names to sample.
            quantities_of_interest (list[str]): List of QoI reporter names to collect.
            options (StochasticRunOptions): Stochastic run configuration options.
            physics_cli_args (list[str]): Additional CLI arguments for the physics app.
            moose_port (int): Optional port number for web server control.
            inherit_environment (bool): Whether or not the MOOSE command will
                                        inherit the current shell environment.
            poll_time (float): Polling time interval for checking MOOSE status.
        """
        self.physics_input: str = physics_input
        self._parameters: list[str] = parameters
        self.num_params: int = self._getNumParams(parameters)
        self._qois: list[str] = quantities_of_interest
        self.num_qois: int = len(self._qois)
        self._opt: StochasticRunOptions = options
        self._physics_cli_args: list[str] = physics_cli_args
        self._input_file = os.path.abspath(self._opt.input_name)

        # Build stochastic input
        self._root: pyhit.Node = self._buildStochasticInput()

        # Initialize base class
        moose_command: list[str] = []
        if self._opt.num_procs > 1:
            moose_command += [self._opt.mpi_command, "-n", str(self._opt.num_procs)]
        moose_command += [executable, "-i", self._opt.input_name]
        moose_command += self._opt.cli_args
        super().__init__(
            moose_command=moose_command,
            moose_control_name=self.web_server_control_name,
            moose_port=moose_port,
            inherit_environment=inherit_environment,
            poll_time=poll_time,
        )

    def __enter__(self) -> "StochasticRunner":
        """
        Context manager entry to return a callable `StochasticRunner` object.
        This enables easy usage in `with` blocks.

        Unfortunately, we cannot initialize the simulation here because the run
        needs a proper input matrix for the first time through.

        Returns:
            StochasticRunner: A callable runner instance.
        """
        return StochasticRunner(self)

    def __exit__(self, exc_type=None, exc_value=None, ex_tb=None):
        """
        Clean up after a run by terminating or killing the MOOSE process
        and removing the temporary input file.
        """
        # Terminate gracefully
        if exc_type is None:
            # If moose is waiting, send a terminate
            try:
                waiting_flag = self.getWaitingFlag()
            except:
                waiting_flag = None
            if not waiting_flag is None:
                self.setTerminate()

            # Don't finalize if we never started
            if self._initialized:
                self.finalize()

        # Kill the simulation if there was an exception
        else:
            self.kill()

        if os.path.exists(self._input_file):
            os.remove(self._input_file)

    def setInput(self, x: np.ndarray):
        """
        Set the input parameter matrix to the sampler.

        If we haven't initialized yet, set the matrix directly in the input
        file; otherwise set the controllable value.

        Parameters:
            x: A NumPy array containing parameter values to sample.
        """
        if not self._initialized:
            # If we haven't started yet, the input matrix should be set at input
            self._sampler["matrix"] = "'" + self._matrixToParameter(x) + "'"
        # Simulation is already started
        else:
            self.wait("TIMESTEP_END")
            self.setControllableMatrix(self.controllable_matrix, x)

    def run(self):
        """
        Executes the MOOSE simulation.
        If not initialized, writes the input and starts a new simulation;
        otherwise continues execution.
        """
        if not self._initialized:
            # Write file
            logger.debug(
                f"Writing input file: {os.path.abspath(self._input_file)}\n{self._root.render()}"
            )
            pyhit.write(self._input_file, self._root)

            self.initialize()
        else:
            self.setContinue()

    def getOutput(self) -> np.ndarray:
        """
        Waits for simulation completion and retrieves QoI reporter values.

        Returns:
            A NumPy array of shape (num_samples, num_qois) with simulation results.
        """
        self.wait("TIMESTEP_END")

        y = []
        for qoi in self._qois:
            rep = f"{self.qoi_storage_name}/" + qoi.replace("/", ":")
            y.append(self.getReporterValue(rep))
        return np.array(y).T

    def _buildStochasticInput(self) -> pyhit.Node:
        """
        Constructs the input file tree for a stochastic MOOSE run.

        Note that the input file is not written until the first input is passed
        in.

        Returns:
            Root pyhit.Node representing the full input file structure.
        """
        # Build root node
        root = pyhit.Node()

        # Add [StochasticTools]
        self._getSyntaxBlockHelper(root, "StochasticTools")

        self._sampler = self._addDynamicSampler(root)
        self._addWebServerControl(root)
        self._addMultiApp(root)
        if self._opt.multiapp_mode.is_restore:
            self._addParameterTransfer(root)
        else:
            self._addParameterControl(root)
        self._addStochasticMatrix(root)
        self._addQoiTransfer(root)

        # Add [Executioner]
        self._getSyntaxBlockHelper(root, "Executioner")["type"] = "Transient"

        return root

    def _addDynamicSampler(self, parent: pyhit.Node) -> pyhit.Node:
        """
        Adds the InputMatrix sampler object.

        Parameters:
            parent (pyhit.Node): The parent pyhit node to add block to (usually root node of input).

        Returns:
            child (pyhit.Node): Pyhit node of the action block.
        """
        # Get the [Samplers] block if one exists, otherwise create one
        samplers = self._getSyntaxBlockHelper(parent, "Samplers")

        # Create parameters
        sampler_params = {
            "type": "InputMatrix",
            "matrix": "'" + " ".join(["0" for _ in range(self.num_params)]) + "'",
            "execute_on": "'MULTIAPP_FIXED_POINT_BEGIN'",
        }
        # Add additional execute_on for batch-reset
        if not self._opt.multiapp_mode.is_restore:
            sampler_params["execute_on"] = (
                "'PRE_MULTIAPP_SETUP " + sampler_params["execute_on"][1:]
            )
        # Add min_procs if requested
        if not self._opt.min_procs_per_sample is None:
            sampler_params["min_procs_per_row"] = self._opt.min_procs_per_sample

        # Build sampler and return
        return samplers.append(self.sampler_name, **sampler_params)

    def _addWebServerControl(self, parent: pyhit.Node) -> pyhit.Node:
        """Add WebServerControl."""
        controls: pyhit.Node = self._getSyntaxBlockHelper(parent, "Controls")
        return controls.append(
            self.web_server_control_name,
            type="WebServerControl",
            execute_on="'TIMESTEP_END'",
        )

    def _addMultiApp(self, parent: pyhit.Node) -> pyhit.Node:
        """Adds MultiApp for the physics input."""
        multiapps = self._getSyntaxBlockHelper(parent, "MultiApps")
        multiapp_params = {
            "type": "SamplerFullSolveMultiApp",
            "input_files": self.physics_input,
            "sampler": self.sampler_name,
            "mode": self._opt.multiapp_mode.mode,
            "execute_on": "'TIMESTEP_BEGIN'",
        }
        if self._opt.ignore_solve_not_converge:
            multiapp_params["ignore_solve_not_converge"] = "true"
        if not self._opt.min_procs_per_sample is None:
            multiapp_params["min_procs_per_app"] = self._opt.min_procs_per_sample
        if (
            self._opt.multiapp_mode
            == StochasticRunOptions.MultiAppMode.BATCH_KEEP_SOLUTION
        ):
            multiapp_params["keep_solution_during_restore"] = "true"
        if (
            self._opt.multiapp_mode
            == StochasticRunOptions.MultiAppMode.BATCH_NO_RESTORE
        ):
            multiapp_params["no_restore"] = "true"

        # Physics command line arguments
        cli_args = self._physics_cli_args[:]
        if self._opt.multiapp_mode.is_restore:
            cli_args.append(
                f"Controls/{self.sample_receiver_name}/type=SamplerReceiver"
            )
        if cli_args:
            multiapp_params["cli_args"] = "'" + ";".join(cli_args) + "'"

        return multiapps.append(self.multiapp_name, **multiapp_params)

    def _addParameterTransfer(self, parent: pyhit.Node) -> pyhit.Node:
        """Add parameter transfer."""
        transfers = self._getSyntaxBlockHelper(parent, "Transfers")
        return transfers.append(
            self.parameter_transfer_name,
            type="SamplerParameterTransfer",
            to_multi_app=self.multiapp_name,
            sampler=self.sampler_name,
            parameters="'" + " ".join(self._parameters) + "'",
        )

    def _addParameterControl(self, parent: pyhit.Node) -> pyhit.Node:
        """Add multiapp command-line control."""
        controls: pyhit.Node = self._getSyntaxBlockHelper(parent, "Controls")
        return controls.append(
            self.parameter_transfer_name,
            type="MultiAppSamplerControl",
            multi_app=self.multiapp_name,
            sampler=self.sampler_name,
            param_names="'" + " ".join(self._parameters) + "'",
        )

    def _addStochasticMatrix(self, parent: pyhit.Node) -> pyhit.Node:
        """
        Add StochasticMatrix reporter object for output of sampling matrix
        and quantities of interest.
        """
        reporters = self._getSyntaxBlockHelper(parent, "Reporters")
        reporter_params = {
            "type": "StochasticMatrix",
            "parallel_type": "ROOT",
            "sampler": self.sampler_name,
            "execute_on": "'TRANSFER'",
        }
        return reporters.append(
            self.qoi_storage_name,
            **reporter_params,
        )

    def _addQoiTransfer(self, parent: pyhit.Node) -> pyhit.Node:
        """Add SamplerReporterTransfer for QoIs."""
        transfers = self._getSyntaxBlockHelper(parent, "Transfers")
        return transfers.append(
            self.qoi_transfer_name,
            type="SamplerReporterTransfer",
            from_multi_app=self.multiapp_name,
            sampler=self.sampler_name,
            stochastic_reporter=self.qoi_storage_name,
            from_reporter="'" + " ".join(self._qois) + "'",
            prefix="''",
        )

    @staticmethod
    def _getSyntaxBlockHelper(parent: pyhit.Node, syntax: str) -> pyhit.Node:
        """Get a node with inputted syntax, if exists. Otherwise add one."""
        for child in parent:
            if child.name == syntax:
                return child
        return parent.append(syntax)

    @staticmethod
    def _getNumParams(parameters: list[str]) -> int:
        """Get number of parameters from the inputted list."""
        num_params: int = 0
        for param in parameters:
            # Not a vector parameter
            if not "[" in param:
                num_params += 1
            # Vector param
            else:
                # Get entries: "param[0,(3.14),1]" -> ["0", "(3.14)", "1"]
                vector_entries = param.split("[")[1][:-1].split(",")
                # Get the max entry
                for entry in vector_entries:
                    if not "(" in entry:
                        num_params = max(int(entry) + 1, num_params)
        return num_params

    @staticmethod
    def _matrixToParameter(matrix: np.ndarray) -> str:
        """Convert a numpy array to a MOOSE-input matrix."""
        assert len(matrix.shape) == 2
        return "; ".join([" ".join([f"{elem:.16g}" for elem in row]) for row in matrix])


class _ResultCache:

    def __init__(self, maxsize: int = 10000, tol: float = 1e-14):
        assert maxsize > 0
        assert tol > 0.0
        self.maxsize = maxsize
        self.tol = tol
        self._cache: OrderedDict[tuple[int, ...], tuple[np.ndarray, np.ndarray]] = (
            OrderedDict()
        )

    def _key(self, row: np.ndarray) -> tuple[int, ...]:
        return tuple(np.rint(row / self.tol).astype(np.int64).tolist())

    def _close(self, a: np.ndarray, b: np.ndarray) -> bool:
        return np.allclose(a, b, rtol=self.tol, atol=0.0)

    def get(self, x: np.ndarray) -> Optional[np.ndarray]:
        k = self._key(x)
        x_ref, y_ref = self._cache.get(k, (None, None))
        if not x_ref is None:
            if self._close(x, x_ref):
                self._cache.move_to_end(k)
                return y_ref
        return None

    def set(self, x: np.ndarray, y: np.ndarray):
        k = self._key(x)
        self._cache[k] = (x.copy(), y.copy())
        self._cache.move_to_end(k)
        if len(self._cache) > self.maxsize:
            self._cache.popitem(False)


class StochasticRunner:
    """
    Callable class that executes the simulation for a given input sample matrix
    and returns the corresponding QoI results.

    This class is designed to be used within a context manager via `StochasticControl`.
    """

    def __init__(self, control: StochasticControl):
        """
        Initializes the StochasticRunner.

        Parameters:
            control (StochasticControl): A StochasticControl instance managing
                                         MOOSE interaction.
        """
        self._control: StochasticControl = control
        self._result_cache: Optional[_ResultCache] = None

    def parallelWorker(self, func: Callable, x_iter: Iterable):
        x = np.array([xi for xi in x_iter])
        if self._result_cache is None:
            self.configCache(len(x_iter))
        elif self._result_cache.maxsize < x.shape[0]:
            self._result_cache.maxsize = x.shape[0]

        self(x)
        for xi in x_iter:
            yield func(xi)

    def configCache(self, maxsize: int = 10000, tol: float = 1e-14):
        if maxsize > 0 and tol > 0.0:
            self._result_cache = _ResultCache(maxsize, tol)
        else:
            self._result_cache = None

    def __call__(self, x_in: np.typing.ArrayLike | float) -> np.ndarray | float:
        """
        Runs the simulation for the provided input(s) and returns the QoIs.

        Parameters:
            x_in (array or float): A single input vector, or array of input vectors.

        Returns:
            A NumPy array or float representing the QoIs.
            - If a single input and single QoI: returns a float.
            - If a single input or single QoI: returns a 1D array.
            - Otherwise, returns a 2D array of shape (num_samples, num_qois).

        Raises:
            ValueError: If the input shape doesn't match expected parameter dimensions.
        """
        # Convert input to numpy array
        x = self._preprocess(x_in)

        # Fast path: no cache
        if self._result_cache is None:
            return self._postprocess(self._run_control(x))

        # Rows that are not in cache
        nrows: int = x.shape[0]
        y = np.empty((nrows, self._control.num_qois))
        need_run_rows: np.ndarray = np.array([True] * nrows, dtype=bool)
        for i in range(nrows):
            y_cache = self._result_cache.get(x[i, :])
            if not y_cache is None:
                need_run_rows[i] = False
                y[i, :] = y_cache

        # Run if any rows are not cached
        if any(need_run_rows):
            y[need_run_rows, :] = self._run_control(x[need_run_rows, :])
            # Store
            for i, store in enumerate(need_run_rows):
                if store:
                    self._result_cache.set(x[i, :], y[i, :])

        # Return
        return self._postprocess(y)

    def _preprocess(self, x_in: np.typing.ArrayLike | float) -> np.ndarray:
        """Convert a iterable or scalar input to a 2-D numpy array."""
        # Convert to numpy array
        x = np.array(x_in)

        # Check dimensionality of array
        dim = len(x.shape)
        if dim == 0:
            x = x.reshape(1, 1)
        elif dim == 1:
            new_shape = (1, -1) if self._control.num_params > 1 else (-1, 1)
            x = x.reshape(new_shape)
        elif dim > 2:
            raise ValueError(
                f"Expecting input to be float, 1-D, or 2-D array; received {dim}-D array."
            )

        # Check array dimensions
        if x.shape[1] != self._control.num_params:
            raise ValueError(
                f"Expecting {self._control.num_params} columns/values in array, got {x.shape[1]}."
            )

        return x

    def _run_control(self, x: np.ndarray) -> np.ndarray:
        # Insert input
        self._control.setInput(x)

        # Run the current state
        self._control.run()

        # Gather reporters
        y = self._control.getOutput()
        if y.shape[0] != x.shape[0]:
            raise self._control.ControlException(
                f"Output length does not match input length: {y.shape[0]} vs. {x.shape[0]}."
            )

        return y

    def _postprocess(self, y: np.ndarray) -> np.ndarray | float:
        """Return either float, vector, or matrix based on size of 2-D array"""
        if np.size(y) == 1:  # A single QoI and row
            return y[0, 0]
        elif 1 in y.shape:  # A single QoI or row
            return y.reshape(-1)
        else:
            return y
